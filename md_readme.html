<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>boost_sqlite: boost.sqlite</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">boost_sqlite<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">A sqlite C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_readme.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">boost.sqlite</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> This library provides a simple C++ sqlite library.</p>
<p>It includes:</p>
<ul>
<li>typed queries</li>
<li>prepared statements</li>
<li>json support</li>
<li>custom functions (scalar, aggregrate, windows)</li>
<li>event hooks</li>
<li>virtual tables</li>
</ul>
<p>sqlite provides an excellent C-API, so this library does not attempt to hide, but to augment it.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Building the library</h1>
<p>You can either build the library and link against <code>boost_sqlite</code> for embedding it, or <code>boost_sqlite_ext</code> for extensions.</p>
<p>If you want to use it for extensions you'll need to define <code>BOOST_SQLITE_COMPILE_EXTENSION</code> or include <code>boost/sqlite/extensions.hpp</code> first.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Quickstart</h1>
<p>First we open a database. Note that this can be <code>":memory:"</code> for an in-memory database.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structboost_1_1sqlite_1_1connection.html">boost::sqlite::connection</a> conn{<span class="stringliteral">&quot;./my-database.db&quot;</span>};</div>
<div class="ttc" id="astructboost_1_1sqlite_1_1connection_html"><div class="ttname"><a href="structboost_1_1sqlite_1_1connection.html">boost::sqlite::connection</a></div><div class="ttdoc">main object for a connection to a database.</div><div class="ttdef"><b>Definition</b> <a href="connection_8hpp_source.html#l00031">connection.hpp:32</a></div></div>
</div><!-- fragment --><p>Next we're creating tables using <a class="el" href="structboost_1_1sqlite_1_1connection.html#a790d727be159156b32b1c69a1aa500cf">boost::sqlite::connection::execute</a>, because it can execute multiple statements in one command:</p>
<div class="fragment"><div class="line">  conn.execute(R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">create table if not exists author (</span></div>
<div class="line"><span class="stringliteral">    id         integer primary key autoincrement,</span></div>
<div class="line"><span class="stringliteral">    first_name text,</span></div>
<div class="line"><span class="stringliteral">    last_name  text</span></div>
<div class="line"><span class="stringliteral">);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">create table if not exists library(</span></div>
<div class="line"><span class="stringliteral">    id      integer primary key autoincrement,</span></div>
<div class="line"><span class="stringliteral">    name    text unique,</span></div>
<div class="line"><span class="stringliteral">    author  integer references author(id)</span></div>
<div class="line"><span class="stringliteral">);</span></div>
<div class="line"><span class="stringliteral">)&quot;</span></div>
<div class="line"><span class="stringliteral">);</span></div>
</div><!-- fragment --><p>Next, we'll use a prepared statement to insert multiple values by index:</p>
<div class="fragment"><div class="line">conn.prepare(<span class="stringliteral">&quot;insert into author (first_name, last_name) values (?1, ?2), (?3, ?4), (?5, ?6), (?7, ?8)&quot;</span>)</div>
<div class="line">    .execute({<span class="stringliteral">&quot;vinnie&quot;</span>, <span class="stringliteral">&quot;falco&quot;</span>, <span class="stringliteral">&quot;richard&quot;</span>, <span class="stringliteral">&quot;hodges&quot;</span>, <span class="stringliteral">&quot;ruben&quot;</span>, <span class="stringliteral">&quot;perez&quot;</span>, <span class="stringliteral">&quot;peter&quot;</span>, <span class="stringliteral">&quot;dimov&quot;</span>});</div>
</div><!-- fragment --><p>Prepared statements can also be used multiple time and used with named parameters instead of indexed.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  conn.query(<span class="stringliteral">&quot;begin transaction;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> st = conn.prepare(<span class="stringliteral">&quot;insert into library (\&quot;name\&quot;, author) values ($library, &quot;</span></div>
<div class="line">                         <span class="stringliteral">&quot;  (select id from author where first_name = $fname and last_name = $lname))&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  st.execute({{<span class="stringliteral">&quot;library&quot;</span>, <span class="stringliteral">&quot;beast&quot;</span>},    {<span class="stringliteral">&quot;fname&quot;</span>, <span class="stringliteral">&quot;vinnie&quot;</span>}, {<span class="stringliteral">&quot;lname&quot;</span>, <span class="stringliteral">&quot;falco&quot;</span>}});</div>
<div class="line">  st.execute({{<span class="stringliteral">&quot;library&quot;</span>, <span class="stringliteral">&quot;mysql&quot;</span>},    {<span class="stringliteral">&quot;fname&quot;</span>, <span class="stringliteral">&quot;ruben&quot;</span>},  {<span class="stringliteral">&quot;lname&quot;</span>, <span class="stringliteral">&quot;perez&quot;</span>}});</div>
<div class="line">  st.execute({{<span class="stringliteral">&quot;library&quot;</span>, <span class="stringliteral">&quot;mp11&quot;</span>},     {<span class="stringliteral">&quot;fname&quot;</span>, <span class="stringliteral">&quot;peter&quot;</span>},  {<span class="stringliteral">&quot;lname&quot;</span>, <span class="stringliteral">&quot;dimov&quot;</span>}});</div>
<div class="line">  st.execute({{<span class="stringliteral">&quot;library&quot;</span>, <span class="stringliteral">&quot;variant2&quot;</span>}, {<span class="stringliteral">&quot;fname&quot;</span>, <span class="stringliteral">&quot;peter&quot;</span>},  {<span class="stringliteral">&quot;lname&quot;</span>, <span class="stringliteral">&quot;dimov&quot;</span>}});</div>
<div class="line"> </div>
<div class="line">  conn.query(<span class="stringliteral">&quot;commit;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we have the values in the table, let's add a custom aggregate function to create a comma separated list:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>collect_libs</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> step(std::string &amp; name, span&lt;sqlite::value, 1&gt; args)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (name.empty())</div>
<div class="line">      name = args[0].get_text();</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      (name += <span class="stringliteral">&quot;, &quot;</span>) += args[0].get_text();</div>
<div class="line">  }</div>
<div class="line">  std::string <span class="keyword">final</span>(std::string &amp; name) { <span class="keywordflow">return</span> name; }</div>
<div class="line">};</div>
<div class="line">sqlite::create_aggregate_function(conn, <span class="stringliteral">&quot;collect_libs&quot;</span>, collect_libs{}); </div>
</div><!-- fragment --><p>Print out the query with aggregates libraries:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_struct" href="structboost_1_1sqlite_1_1row.html">boost::sqlite::row</a> r : conn.query(</div>
<div class="line">    <span class="stringliteral">&quot;select first_name, collect_libs(name) &quot;</span></div>
<div class="line">       <span class="stringliteral">&quot; from author inner join library l on author.id = l.author group by last_name&quot;</span>))</div>
<div class="line">  std::cout &lt;&lt; r.at(0u).get_text() &lt;&lt; <span class="stringliteral">&quot; authored &quot;</span> &lt;&lt; r.at(1u).get_text() &lt;&lt; std::endl;</div>
<div class="ttc" id="astructboost_1_1sqlite_1_1row_html"><div class="ttname"><a href="structboost_1_1sqlite_1_1row.html">boost::sqlite::row</a></div><div class="ttdoc">Representation of a row in a database.</div><div class="ttdef"><b>Definition</b> <a href="row_8hpp_source.html#l00020">row.hpp:21</a></div></div>
</div><!-- fragment --><p>Alternatively a query result can also be read manually instead of using a loop:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structboost_1_1sqlite_1_1row.html">boost::sqlite::row</a> r;</div>
<div class="line">boost::sqlite::query q = conn.query(</div>
<div class="line">    <span class="stringliteral">&quot;select first_name, collect_libs(name) &quot;</span> </div>
<div class="line">       <span class="stringliteral">&quot; from author inner join library l on author.id = l.author group by last_name&quot;</span>)</div>
<div class="line"><span class="keywordflow">do</span> </div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> r = q.current();<span class="stringliteral">&#39;&#39;</span></div>
<div class="line">  std::cout &lt;&lt; r.<a class="code hl_function" href="structboost_1_1sqlite_1_1row.html#ae2bbb7c0e388f499c91b538f4e6c10de">at</a>(0u).<a class="code hl_function" href="structboost_1_1sqlite_1_1field.html#a4ddabf9e516f7110cfd2f1095aa87210">get_text</a>() &lt;&lt; <span class="stringliteral">&quot; authored &quot;</span> &lt;&lt; r.<a class="code hl_function" href="structboost_1_1sqlite_1_1row.html#ae2bbb7c0e388f499c91b538f4e6c10de">at</a>(1u).<a class="code hl_function" href="structboost_1_1sqlite_1_1field.html#a4ddabf9e516f7110cfd2f1095aa87210">get_text</a>() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">while</span> (q.read_next());</div>
<div class="ttc" id="astructboost_1_1sqlite_1_1field_html_a4ddabf9e516f7110cfd2f1095aa87210"><div class="ttname"><a href="structboost_1_1sqlite_1_1field.html#a4ddabf9e516f7110cfd2f1095aa87210">boost::sqlite::field::get_text</a></div><div class="ttdeci">cstring_ref get_text() const</div><div class="ttdoc">Returns the value as text, i.e. a string_view. Note that this value may be invalidated`.</div></div>
<div class="ttc" id="astructboost_1_1sqlite_1_1row_html_ae2bbb7c0e388f499c91b538f4e6c10de"><div class="ttname"><a href="structboost_1_1sqlite_1_1row.html#ae2bbb7c0e388f499c91b538f4e6c10de">boost::sqlite::row::at</a></div><div class="ttdeci">field at(std::size_t idx) const</div><div class="ttdoc">Returns the field at idx,.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Fields, values &amp; parameters</h1>
<p>sqlite3 has a weak typesystem, where everything is one of following <a class="el" href="group__reference.html#ga54803a0f6eb577b3e3938ca6dc3f6818">value_types</a>:</p>
<ul>
<li><code>integer</code></li>
<li><code>floating</code></li>
<li><code>text</code></li>
<li><code>blob</code></li>
<li><code>null</code></li>
</ul>
<p>The result of a query is a <a class="el" href="structboost_1_1sqlite_1_1field.html">field</a> type, while a <a class="el" href="structboost_1_1sqlite_1_1value.html">value</a> is used in functions.</p>
<p>Fields &amp; values can have <a href="https://www.sqlite.org/c3ref/value_subtype.html">subtypes</a>, while parameter to prepared statements do not have thos associated.</p>
<p>Because of this the values that can be bound to an <a class="el" href="structboost_1_1sqlite_1_1statement.html#a0b7b0e468010d8bf49fb1681f6c87ef5">execute</a> need to be convertible to a fixed set of types (see <a class="el" href="structboost_1_1sqlite_1_1param__ref.html">param_ref</a> for details).</p>
<p>When a <a class="el" href="structboost_1_1sqlite_1_1value.html">value</a> is returned from a custom function, such as done through <a class="el" href="group__reference.html#ga78a6f35f2e7b808198bfec06d7561b0a">create_scalar_function</a>, additional types can be added with the following tag_invoke function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> tag_invoke(<span class="keyword">const</span> <span class="keyword">struct</span> set_result_tag &amp;, sqlite3_context * ctx, <span class="keyword">const</span> my_type &amp; value);</div>
</div><!-- fragment --><p>An implementation can look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> tag_invoke(<span class="keyword">const</span> <span class="keyword">struct</span> set_result_tag &amp;, sqlite3_context * ctx, <span class="keyword">const</span> my_type &amp; value)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> data = value.to_string();</div>
<div class="line">  sqlite3_result_text(ctx, data.c_str(), data.size(), sqlite3_free);</div>
<div class="line">  sqlite3_result_subtype(ctx, my_subtype);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Typed queries</h1>
<p>Queries can be typed through tuples, describe or, if you're on C++20, by plain structs. The type to hold them is <code>static_resultset&lt;T&gt;</code> which will check if the columns match the result types before usage. Tuples are matched by position, structs by name.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> q : conn.query&lt;std::tuple&lt;std::string, std::string&gt;&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;select first_name, collect_libs(name) &quot;</span></div>
<div class="line">       <span class="stringliteral">&quot; from author inner join library l on author.id = l.author group by last_name&quot;</span>))</div>
<div class="line">  std::cout &lt;&lt; std::get&lt;0&gt;(q) &lt;&lt; <span class="stringliteral">&quot; authored &quot;</span> &lt;&lt; std::get&lt;0&gt;(q) &lt;&lt; std::endl;</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>query_result { std::string first_name, lib_name;};</div>
<div class="line">BOOST_DESCRIBE_STRUCT(query_result, (), (first_name, lib_name)); <span class="comment">// this can be omitted with C++20. </span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> q : conn.query&lt;query_result&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;select first_name, collect_libs(name) as lib_name&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot; from author inner join library l on author.id = l.author group by last_name&quot;</span>))</div>
<div class="line">  std::cout &lt;&lt; q.first_name &lt;&lt; <span class="stringliteral">&quot; authored &quot;</span> &lt;&lt; q.lib_name &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The following types are allowed in a static query result:</p>
<ul>
<li><code>sqlite::value</code></li>
<li><code>int</code></li>
<li><code>sqlite_int64</code></li>
<li><code>double</code></li>
<li><code>std::string</code></li>
<li><code>sqlite::string_view</code></li>
<li><code>sqlite::blob</code></li>
<li><code>sqlite::blob_view</code></li>
</ul>
<p>You'll need to include <code><a class="el" href="static__resultset_8hpp_source.html">boost/sqlite/static_resultset.hpp</a></code> for this to work.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Custom functions</h1>
<p>Since sqlite is running in the same process you can add custom functions that can be used from within sqlite.</p>
<ul>
<li><a class="el" href="group__reference.html#ga4b78f9ea6818419127459b88326929ed">collation</a></li>
<li><a class="el" href="group__reference.html#ga78a6f35f2e7b808198bfec06d7561b0a">scalar function</a></li>
<li><a class="el" href="group__reference.html#gad518e22393ac440795f7e130c4dad0a7">aggregate function</a></li>
<li>window function</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Vtables</h1>
<p>This library also simplifies adding virtual tables significantly; virtual tables are table that are backed by code instead of data.</p>
<p>See <a class="el" href="group__reference.html#ga6970e74adf1b067a03ad409740368102">create_module</a> and prototype for more details.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Modules</h1>
<p>This library can also be used to build a sql plugin:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__reference.html#ga5fcce434a49622839d917d3c41b3c513">BOOST_SQLITE_EXTENSION</a>(testlibrary, conn)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// create a function that can be used in the plugin</span></div>
<div class="line">  create_scalar_function(</div>
<div class="line">    conn, <span class="stringliteral">&quot;assert&quot;</span>,</div>
<div class="line">    [](boost::sqlite::context&lt;&gt;, boost::span&lt;boost::sqlite::value, 1u&gt; sp)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (sp.front().get_int() == 0)</div>
<div class="line">          <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;assertion failed&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="agroup__reference_html_ga5fcce434a49622839d917d3c41b3c513"><div class="ttname"><a href="group__reference.html#ga5fcce434a49622839d917d3c41b3c513">BOOST_SQLITE_EXTENSION</a></div><div class="ttdeci">#define BOOST_SQLITE_EXTENSION(Name, Conn)</div><div class="ttdoc">Declare a sqlite module.</div><div class="ttdef"><b>Definition</b> <a href="extension_8hpp_source.html#l00047">extension.hpp:47</a></div></div>
</div><!-- fragment --><p>The plugin can then be loaded &amp; used like this:</p>
<div class="fragment"><div class="line"><span class="keyword">SELECT</span> load_extension(<span class="stringliteral">&#39;./test_library&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">select</span> assert((<span class="stringliteral">3</span> * <span class="stringliteral">4</span>) = <span class="stringliteral">12</span>);</div>
</div><!-- fragment --><p>To build a plugin you need to define <code>BOOST_SQLITE_COMPILE_EXTENSION</code> (e.g. by including <code><a class="el" href="extension_8hpp_source.html">boost/sqlite/extension.hpp</a></code> or linking against <code>boost_sqlite_ext</code>).</p>
<p>This will include the matching sqlite header (<code>sqlite3ext.h</code>) and will move all the symbols into an inline namespace <code>ext</code> inside <code>boost::sqlite</code>. <br  />
</p>
<p><a class="anchor" id="api-reference"></a> </p>
<h1><a class="anchor" id="autotoc_md8"></a>
Reference</h1>
<ul>
<li><a class="el" href="group__reference.html">Reference</a>: Complete API documentation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
Library Comparisons</h1>
<p>While there are many sqlite wrappers out there, most haven't been updated in the last five years - while sqlite has.</p>
<p>Here are some actively maintained ones:</p>
<ul>
<li><a href="https://github.com/SRombauts/SQLiteCpp">SQLiteCpp</a></li>
</ul>
<p>SQLiteCpp is the closest to this library, a C++11 wrapper only depending on sqlite &amp; the STL. It's great and served as an inspiration for this library. boost.sqlite does provide more functionality when it comes to hooks, custom functions &amp; virtual tables. Furthermore, boost.sqlite has a non-throwing interface and supports variants &amp; json, as those are available through boost.</p>
<ul>
<li><a href="https://github.com/SqliteModernCpp/sqlite_modern_cpp">sqlite_modern_cpp</a></li>
</ul>
<p>This library takes a different approach, by making everything an <code>iostream</code> interface. <code>iostream</code> interfaces have somewhat fallen out of favor.</p>
<ul>
<li><a href="https://github.com/fnc12/sqlite_orm">sqlite_orm</a></li>
</ul>
<p>As the name says, it's an ORM. While there is nothing wrong with ORMs, they are one layer of abstraction above a client library like this.</p>
<ul>
<li><a href="https://github.com/SOCI/soci">SOCI</a></li>
</ul>
<p>SOCI is an abstraction layer for multiple databases in C++, including sqlite. It's interfaces encourages dynamic building of query string, which should not be considered safe. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Nov 11 2024 12:54:56 for boost_sqlite by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
